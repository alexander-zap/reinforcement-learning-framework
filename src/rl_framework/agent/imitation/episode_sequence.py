import itertools
from typing import Generator, Iterable, List, Sequence, Sized, Tuple, cast

import d3rlpy
import imitation
import imitation.data.types
import numpy as np
from imitation.data import serialize

from rl_framework.util import SizedGenerator

GenericEpisode = List[Tuple[object, object, object, float, bool, bool, dict]]


class EpisodeSequence(Iterable[GenericEpisode], Sized):
    """
    Class to load, transform and iterate over episodes, optimized for memory efficiency.
        - Using HuggingFace "load_from_disk" for loading
        - Using generators for underlying data management
        - Format changing transformations also return generators

    The sampling logic and order of episode generation is fully controlled by the `self._episode_generator` attribute.

    Each episode consists of a sequence, which has the following format:
        [
            (obs_t0, action_t0, next_obs_t0, reward_t0, terminated_t0, truncated_t0, info_t0),
            (obs_t1, action_t1, next_obs_t1, reward_t1, terminated_t1, truncated_t1, info_t1),
            ...
        ]
        Interpretation: Transition from obs to next_obs with action, receiving reward.
            Additional information returned about transition to next_obs: terminated, truncated and info.

    NOTE: Please remember that any results of the format changing `to_` operation will be using the same generator.
        Iterating over the resulting format-changed generators still consumes the internal generator of EpisodeSequence.
    """

    def __init__(self):
        def empty() -> Generator:
            yield from ()

        self._episode_generator: Generator[GenericEpisode, None, None] = empty()
        self._len = 0
        self._looping = False

    def __len__(self):
        return self._len

    def __iter__(self):
        return self._episode_generator

    @staticmethod
    def from_episode_generator(
        episode_generator: Generator[GenericEpisode, None, None], n_episodes: int
    ) -> "EpisodeSequence":
        """
        Initialize an EpisodeSequence based on a provided generator (of GenericEpisode objects).

        Args:
            episode_generator (Generator): Custom episode generator generating GenericEpisodes
                every time __next__() is called.
            n_episodes (int): Amount of episodes the generator will generate (to limit infinite generators).
                If amount of generated elements from generator are already known, pass it as "n_episodes".

        NOTE: Loading an EpisodeSequence from a generator does not support looping.
            If this behavior is wished, make sure the `episode_generator` itself is looping instead.

        Returns:
            episode_sequence: Representation of episode sequence (this class).
        """
        episode_sequence = EpisodeSequence()
        episode_sequence._episode_generator = itertools.islice(episode_generator, n_episodes)
        episode_sequence._len = n_episodes
        episode_sequence._looping = False
        return episode_sequence

    @staticmethod
    def from_episodes(episodes: Sequence[GenericEpisode], loop: bool = False) -> "EpisodeSequence":
        """
        Initialize an EpisodeSequence based on a sequence of GenericEpisode objects.

        Args:
            episodes (Sequence[GenericEpisode]): Episodes in generic format.
            loop (bool): Flag whether the generator should loop over the episodes repeatedly.

        Returns:
            episode_sequence: Representation of episode sequence (this class).
        """

        def generate_episodes(
            owner_of_generator: EpisodeSequence, generic_episodes: Sequence[GenericEpisode]
        ) -> Generator[GenericEpisode, None, None]:
            while True:
                for episode in generic_episodes:
                    yield episode
                if not owner_of_generator._looping:
                    break

        episode_sequence = EpisodeSequence()
        episode_sequence._episode_generator = generate_episodes(episode_sequence, episodes)
        episode_sequence._len = len(episodes)
        episode_sequence._looping = loop
        return episode_sequence

    @staticmethod
    def from_dataset(file_path: str, loop: bool = False) -> "EpisodeSequence":
        """
        Initialize an EpisodeSequence based on provided huggingface dataset path.

        Episode sequences are loaded from a provided file path in the agent section of the config.
        Files of recorded episode sequences are generated by saving Trajectory objects (`imitation` library).
        https://imitation.readthedocs.io/en/latest/main-concepts/trajectories.html#storing-loading-trajectories

        Args:
            file_path (str): Path to huggingface dataset recording of episodes.
            loop (bool): Flag whether the generator should loop over the dataset repeatedly.

        Returns:
            episode_sequence: Representation of episode sequence (this class).
        """

        def generate_episodes(
            owner_of_generator: EpisodeSequence,
            imitation_trajectories: Sequence[imitation.data.types.TrajectoryWithRew],
        ) -> Generator[GenericEpisode, None, None]:
            while True:
                for trajectory in imitation_trajectories:
                    obs = trajectory.obs[:-1]
                    acts = trajectory.acts
                    rews = trajectory.rews
                    next_obs = trajectory.obs[1:]
                    terminations = np.zeros(len(trajectory.acts), dtype=bool)
                    truncations = np.zeros(len(trajectory.acts), dtype=bool)
                    terminations[-1] = trajectory.terminal
                    truncations[-1] = not trajectory.terminal
                    infos = np.array([{}] * len(trajectory)) if trajectory.infos is None else trajectory.infos
                    episode: GenericEpisode = list(zip(*[obs, acts, next_obs, rews, terminations, truncations, infos]))
                    yield episode
                if not owner_of_generator._looping:
                    break

        episode_sequence = EpisodeSequence()
        trajectories = cast(Sequence[imitation.data.types.TrajectoryWithRew], serialize.load(file_path))
        episode_sequence._episode_generator = generate_episodes(episode_sequence, trajectories)
        episode_sequence._len = len(trajectories)
        episode_sequence._looping = loop
        return episode_sequence

    def save(self, file_path):
        """
        Save episode sequence into a file, saved as HuggingFace dataset.

        Args:
            file_path: File path and file name to save episode sequence to.
        """
        self._looping = False
        trajectories: Sequence[imitation.data.types.TrajectoryWithRew] = list(self.to_imitation_episodes())
        serialize.save(file_path, trajectories)

    def to_imitation_episodes(self) -> SizedGenerator[imitation.data.types.TrajectoryWithRew]:
        def generate_imitation_episodes():
            for generic_episode in self._episode_generator:
                observations, actions, next_observations, rewards, terminations, truncations, infos = (
                    np.array(x) for x in list(zip(*generic_episode))
                )
                observations = np.expand_dims(observations, axis=1) if observations.ndim == 1 else observations
                next_observations = (
                    np.expand_dims(next_observations, axis=1) if next_observations.ndim == 1 else next_observations
                )
                all_observations = np.vstack([observations, next_observations[-1:]])
                episode_trajectory = imitation.data.types.TrajectoryWithRew(
                    obs=all_observations, acts=actions, rews=rewards, infos=infos, terminal=terminations[-1]
                )
                yield episode_trajectory

        return SizedGenerator(generate_imitation_episodes(), len(self), self._looping)

    def to_d3rlpy_episodes(self) -> SizedGenerator[d3rlpy.dataset.components.Episode]:
        def generate_d3rlpy_episodes():
            for generic_episode in self._episode_generator:
                observations, actions, next_observations, rewards, terminations, truncations, infos = (
                    np.array(x) for x in list(zip(*generic_episode))
                )
                episode = d3rlpy.dataset.components.Episode(
                    observations=observations,
                    actions=actions,
                    rewards=rewards,
                    terminated=terminations[-1],
                )
                yield episode

        return SizedGenerator(generate_d3rlpy_episodes(), len(self), self._looping)

    def to_generic_episodes(self) -> SizedGenerator[GenericEpisode]:
        def generate_generic_episodes():
            return self._episode_generator

        return SizedGenerator(generate_generic_episodes(), len(self), self._looping)
